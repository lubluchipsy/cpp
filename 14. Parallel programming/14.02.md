При запуске потоков появляются накладные расходы, связанные с тем, что ОС должна выделить ресурсы ядра и память для стека и сообщить о новом потоке планировщику. Если задача, исполняемая в отдельном потоке, завер-
шается быстро, то может оказаться, что в общем времени ее работы доминируют именно накладные расходы на запуск потока, поэтому производительность приложения в целом может оказаться хуже, чем если бы задача исполнялась в уже имеющемся потоке.
Чем больше потоков работает, тем чаще система должна предпринимать контекстное переключение. Это замедляет выполнение программы, ведь пока система переключается, полезная работа не совершается. В связи с этим необходимо понимать, что число потоков нужно выбирать исходя из имеющегося аппаратного параллелизма.
При использовании потоков необходимо учитывать сложность задачи и аппаратные возможности устройства. Также если для проектирования задачи проивзодительность не так важна, потоки дают небольшой выигрыш, не стоит их использовать. Они усложняют понимание кода, его тестирование и отладку.
Распределение данных между потоками тоже можно выполнить по-разному. Можно каждому потоку давать на обработку одинаковую часть данных, а можно распределять их рекурсивно. Рекурсивное распределение выгодно, например, при сортировке, когда изначально состав половин не ясен. В таком случае необходимо контролировать количество созданных потоков, ведь когда их слишком много, производительность уменьшается. С этим справляется std::async
Работу можно распределять не только по данным, но и по типу работы, то есть каждому потоку выделять определенную функцию. Это удобно, потому что операционная система будет заниматься синхронизацией потоков, если правильно спроектировать код. Если задача заключается в применении одной последовательнос-
ти операций ко многим независимым элементам данных, то можно организовать распараллеленный конвейер. Здесь можно провести аналогию с физическим конвейером: данные поступают с одного конца, подвергаются ряду операций и выходят с другого конца.
